.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::SSH::Expect 3"
.TH Net::SSH::Expect 3 "2008-04-23" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::SSH::Expect \- SSH wrapper to execute remote commands
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Net::SSH::Expect;
\&
\&        #
\&        # You can do SSH authentication with user\-password or without it.
\&        #
\&
\&        # Making an ssh connection with user\-password authentication
\&        # 1) construct the object
\&        my $ssh = Net::SSH::Expect\->new (
\&            host => "myserver.com", 
\&            password=> \*(Aqpass87word\*(Aq, 
\&            user => \*(Aqbnegrao\*(Aq, 
\&            raw_pty => 1
\&        );
\&
\&        # 2) logon to the SSH server using those credentials.
\&        # test the login output to make sure we had success
\&        my $login_output = $ssh\->login();
\&        if ($login_output !~ /Welcome/) {
\&            die "Login has failed. Login output was $login_output";
\&        }
\&        
\&        # \- now you know you\*(Aqre logged in \- #
\&
\&        # Starting ssh without password
\&        # 1) run the constructor
\&        my $ssh = Net::SSH::Expect\->new (
\&            host => "myserver.com", 
\&            user => \*(Aqbnegrao\*(Aq, 
\&            raw_pty => 1
\&        );
\&        # 2) now start the ssh process
\&        $ssh\->run_ssh() or die "SSH process couldn\*(Aqt start: $!";
\&        
\&        # 3) you should be logged on now. Test if you received the remote prompt:
\&        ($ssh\->read_all(2) =~ />\es*\ez/) or die "where\*(Aqs the remote prompt?"
\&
\&        # \- now you know you\*(Aqre logged in \- #
\&
\&        # disable terminal translations and echo on the SSH server
\&        # executing on the server the stty command:
\&        $ssh\->exec("stty raw \-echo");
\&
\&        # runs arbitrary commands and print their outputs 
\&        # (including the remote prompt comming at the end)
\&        my $ls = $ssh\->exec("ls \-l /");
\&        print($ls);
\&        
\&        my $who = $ssh\->exec("who");
\&        print ($who);
\&        
\&        # When running a command that causes a huge output,
\&        # lets get the output line by line:
\&        $ssh\->send("find /");   # using send() instead of exec()
\&        my $line;
\&        # returns the next line, removing it from the input stream:
\&        while ( defined ($line = $ssh\->read_line()) ) {
\&            print $line . "\en";  
\&        }
\&
\&        # take a look in what is immediately available on the input stream
\&        print $ssh\->peek(0);    # you\*(Aqll probably see the remote prompt
\& 
\&        # the last read_line() on the previous loop will not include the
\&        # remote prompt that appears at the end of the output, because the prompt
\&        # doesn\*(Aqt end with a \*(Aq\en\*(Aq character. So let\*(Aqs remove the remainder
\&        # prompt from the input stream:
\&        $ssh\->eat($ssh\->peek(0));  # removes whatever is on the input stream now
\&
\&        # We can also iterate over the output in chunks,
\&        # printing everything that\*(Aqs available at each 1 second:
\&        $ssh\->send ("find /home");
\&        my $chunk;
\&        while ($chunk = $ssh\->peek(1)) { # grabs chunks of output each 1 second
\&            print $ssh\->eat($chunk);
\&        }
\&
\&        # Now let\*(Aqs run an interactive command, like passwd.
\&        # This is done combining send() and waitfor() methods together:
\&        $ssh\->send("passwd");
\&        $ssh\->waitfor(\*(Aqpassword:\es*\ez\*(Aq, 1) or die "prompt \*(Aqpassword\*(Aq not found after 1 second";
\&        $ssh\->send("curren_password");
\&        $ssh\->waitfor(\*(Aq:\es*\ez\*(Aq, 1) or die "prompt \*(AqNew password:\*(Aq not found";
\&        $ssh\->send("new_password");
\&        $ssh\->waitfor(\*(Aq:\es*\ez\*(Aq, 1) or die "prompt \*(AqConfirm new password:\*(Aq not found";
\&        $ssh\->send("new_password");
\&
\&        # check that we have the system prompt again.
\&        my ($before_match, $match) = $ssh\->waitfor(\*(Aq>\es*\ez\*(Aq, 1);  # waitfor() in a list context
\&        die "passwd failed. passwd said \*(Aq$before_match\*(Aq." unless ($match);
\&
\&        # closes the ssh connection
\&        $ssh\->close();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is a wrapper to the \fIssh\fR executable that is available in your system's \fI\f(CI$PATH\fI\fR.
Use this module to execute commands on the remote \s-1SSH\s0 server.
It authenticates with the user and password you passed in the constructor's attributes
\&\f(CW\*(C`user\*(C'\fR and \f(CW\*(C`password\*(C'\fR.
.PP
Once an ssh connection was started using the \f(CW\*(C`connect()\*(C'\fR method it will remain open
until you call the \f(CW\*(C`close()\*(C'\fR method. This allows you execute as many commands as you want
with the \f(CW\*(C`exec()\*(C'\fR method using only one connection. This is a better approach over other 
ssh wrapper implementations, i.e: Net::SCP, Net::SSH and Net::SCP::Expect, that start a new
ssh connection each time a remote command is issued or a file is transfered.
.PP
It uses \fIExpect.pm\fR module to interact with the \s-1SSH\s0 server. A \f(CW\*(C`get_expect()\*(C'\fR method is 
provided so you can obtain the internal \f(CW\*(C`Expect\*(C'\fR object connected to the \s-1SSH\s0 server. Use 
this only if you have some special need that you can't do with the \f(CW\*(C`exec()\*(C'\fR method.
.PP
This module was inspired by Net::SCP::Expect <http://search.cpan.org/~djberg/Net\-SCP\-Expect\-0.12/Expect.pm>
and by Net::Telnet and some of its methods work the same as these two modules.
.SS "\s-1IMPORTANT\s0 \s-1NOTES\s0 \s-1ABOUT\s0 \s-1DEALING\s0 \s-1WITH\s0 \s-1SSH\s0 \s-1AND\s0 PSEUDO-TERMINALS"
.IX Subsection "IMPORTANT NOTES ABOUT DEALING WITH SSH AND PSEUDO-TERMINALS"
This module uses Expect to start the local ssh client process, and Expect will interact with this process
through a local pseudo-terminal (ptty). Similarly, the ssh client will connect to the \s-1SSH\s0 server and
there will receive an ssh login process attached to a ptty too.
.PP
During my tests I realized that the I/O to and from the ssh server changes drastically from \s-1OS\s0 to \s-1OS\s0
if we let the local and remote pttys configured on their defaults. The echo's and the \er\en translations
make a mess that we are never sure what will be sent to the other side and what will be received here.
.PP
Many ptty features are system dependent and we can't rely on them working the same on different \s-1OS\s0's.
.PP
To avoid these problems I always recommend you to:
.PP
1) enable the 'raw_pty' constructor attribute. This disables most (if not all) of the problematic features 
on the local ptty.
.PP
2) Similarly set the ptty on the remote server to 'raw \-echo' as soon as you login.
This can be done with:
.PP
.Vb 1
\&    $ssh\->exec("stty raw \-echo");
.Ve
.PP
Obviously your server must support the 'stty' command for that.
.PP
3) If you won't run on the server interactive commands that prompt for input, like 'passwd', you
could prevent the ssh server from attributing a ptty for the ssh login process. This is done
by enabling the 'no_terminal' constructor attribute. What that does is passing the '\-T' option
to the ssh client process when it is created. From the \s-1BSD\s0 ssh client manual:
    \-T      Disable pseudo-tty allocation.
.PP
This will create the cleaner connection possible. You won't have a ptty on the server, and, 
weirdly, you won't receive a remote prompt. Try yourself 'ssh \-T my.ssh.server' to see how it
works. Notice that some system commands that rely on a terminal won't work, say, 'who am i',
\&'stty', etc.
.PP
Also, interactive commands like 'passwd' or 'mail' won't be able to print their prompts.
.PP
But other system commands will run better: 'ls \-l' will be printed without terminal control characters.
\&'ps \-ef' will have the command lines printed fully, since there is no 'columns' terminal limitation.
.PP
Moral of the story: pseudo terminals do many character translations that can bring some unexpected results
in some situations. Avoid them if you can.
.SH "EXPORT"
.IX Header "EXPORT"
None by default.
.SH "CONSTRUCTOR ATTRIBUTES"
.IX Header "CONSTRUCTOR ATTRIBUTES"
The constructor accepts all the following attributes that can be set in the form of attribute => 'value' pairs.
They are presentend in three groups: 
1) attributes to configure the ssh client process;
2) attributes to configure the underlying Expect object;
3) attributes to configure this module;
.SS "\s-1ATTRIBUTES\s0 \s-1TO\s0 \s-1CONFIGURE\s0 \s-1THE\s0 \s-1SSH\s0 \s-1CLIENT\s0 \s-1PROCESS\s0"
.IX Subsection "ATTRIBUTES TO CONFIGURE THE SSH CLIENT PROCESS"
Some of the attributes bellow will enable/disable some options of the ssh client. Refer to you ssh client documentation
to know what each one does.
.IP "string \fBbinary\fR" 4
.IX Item "string binary"
the complete path to the 'ssh' executable in your machine. The default is 'ssh' what means the ssh used by default is the first one found in your \f(CW$PATH\fR environment variable.
.IP "string \fBuser\fR" 4
.IX Item "string user"
the username to login.
.IP "string \fBpassword\fR" 4
.IX Item "string password"
the password used to login. You won't need to set this field if you have public-key authentication configured for you ssh user. Read \fIrun_ssh()\fR documentation for more info.
.IP "string \fBhost\fR" 4
.IX Item "string host"
the address(dns name/ip) to the ssh server
.IP "string \fBport\fR" 4
.IX Item "string port"
Feeds the \-p ssh client option with alternate ssh port. This option is not set by default.
.IP "boolean \fBno_terminal\fR" 4
.IX Item "boolean no_terminal"
If enabled adds the \-T ssh client option to the ssh command line. See the discussion on \*(L"\s-1IMPORTANT\s0 \s-1NOTES\s0 
\&\s-1ABOUT\s0 \s-1DEALING\s0 \s-1WITH\s0 \s-1SSH\s0 \s-1AND\s0 PSEUDO-TERMINALS\*(R" to know if you want to enable this.
.IP "char \fBescape_char\fR" 4
.IX Item "char escape_char"
Passes a character to the \-e ssh client option. This enables ssh escapes. Since this
option can cause trouble, it is explicitly turned off by default with a '\-e none' option 
being set on the ssh command line.
.IP "string \fBssh_option\fR" 4
.IX Item "string ssh_option"
This lets you add your own ssh options to the command line. Set this string to the options you want,
like '\-v \-p 2022', and your options will be added to the ssh command line that will start the ssh process.
.SS "\s-1CONSTRUCTOR\s0 \s-1OPTIONS\s0 \s-1THAT\s0 \s-1CONFIGURE\s0 \s-1THE\s0 \s-1INTERNAL\s0 \s-1EXPECT\s0 \s-1OBJECT\s0"
.IX Subsection "CONSTRUCTOR OPTIONS THAT CONFIGURE THE INTERNAL EXPECT OBJECT"
The following constructor attributes can be used to configure special features of the internal Expect object used to communicate with the ssh server. These options will be passed to the Expect object inside the \f(CW\*(C`connect\*(C'\fR method before it spawns the ssh process.
.IP "string \fBlog_file\fR" 4
.IX Item "string log_file"
Used as argument to the internal Expect\->\fIlog_file()\fR method. Default is no logfile.
.IP "boolean \fBlog_stdout\fR" 4
.IX Item "boolean log_stdout"
Used as argument to the internal Expect\->\fIlog_sdtout()\fR method. Default is 0, to disable log to stdout.
.IP "boolean \fBexp_internal\fR" 4
.IX Item "boolean exp_internal"
Argument to be passed to the internal Expect\->\fIexp_internal()\fR method. Default is 0, to disable the internal exposure.
.IP "boolean \fBexp_debug\fR" 4
.IX Item "boolean exp_debug"
Argument to be passed to the internal Expect\->\fIdebug()\fR method. Default is 0, to disable debug.
.IP "boolean \fBraw_pty\fR" 4
.IX Item "boolean raw_pty"
Argument to be passed to the internal Expect\->\fIraw_pty()\fR method. It's recommended that you enable this. See the disscussion
in \*(L"\s-1IMPORTANT\s0 \s-1NOTES\s0 \s-1ABOUT\s0 \s-1DEALING\s0 \s-1WITH\s0 \s-1SSH\s0 \s-1AND\s0 PSEUDO-TERMINALS\*(R" to know why.
Default is 0 to let the local ptty as its defaults.
.IP "boolean \fBrestart_timeout_upon_receive\fR" 4
.IX Item "boolean restart_timeout_upon_receive"
If this is enabled the timeout in all reading operations works as an inactivity timeout \- it'll not start counting
while there is data arriving on input stream. Default is 0.
.SS "\s-1CONSTRUCTOR\s0 \s-1OPTIONS\s0 \s-1TO\s0 \s-1CONFIGURE\s0 \s-1THIS\s0 \s-1MODULE\s0"
.IX Subsection "CONSTRUCTOR OPTIONS TO CONFIGURE THIS MODULE"
.IP "string \fBterminator\fR" 4
.IX Item "string terminator"
the line terminator in use on the \s-1SSH\s0 server, this will added at the end of each command
passed to the \f(CW\*(C`exec()\*(C'\fR method. The default is \f(CW\*(C`\en\*(C'\fR.
.Sp
It also affects the \fIread_line()\fR method, it expect each line to be terminated by the 'teminator'
character. Lines can also be ended with \*(L"\er\*(R" or \*(L"\er\en\*(R" in some systems.
Remember to adjust this for your system.
.Sp
You can also use the \fIterminator()\fR method to set this attribute.
.IP "integer \fBtimeout\fR" 4
.IX Item "integer timeout"
The maximum time to wait for a pattern to show up on input stream before giving up
in a read operation. The default is 1 second.
.Sp
Timeout must always be an integer >= 0.
.Sp
This attribute can also be get/set with the \f(CW\*(C`timeout()\*(C'\fR method.
.IP "boolean \fBdebug\fR" 4
.IX Item "boolean debug"
Causes some methods to print debug messages to the \s-1STDERR\s0. This feature is not widely implemented yet. 
(only \fIeat()\fR implements it until this moment)
.SH "METHODS"
.IX Header "METHODS"
.IP "boolean \fB\f(BIrun_ssh()\fB\fR \- forks the ssh client process" 4
.IX Item "boolean run_ssh() - forks the ssh client process"
.Vb 10
\&        # boolean run_ssh() \- forks the ssh client process opening an ssh connection to the SSH server.
\&        #
\&        #       This method has three roles:
\&        #       1)      Instantiate a new Expect object configuring it with all the defaults and user\-defined
\&        #               settings.
\&        #       2)      Define the ssh command line using the defaults and user\-defined settings
\&        #       3)      Fork the ssh process using the spawn() method of the Expect instance we created. 
\&        #               The SSH connection is established on this step using the user account set in the \*(Aquser\*(Aq
\&        #               constructor attribute. No password is sent here, that happens only in the login() method.
\&        #
\&        #       This method is run internally by the login() method so you don\*(Aqt need to run it yourself
\&        #       in most of the cases. You\*(Aqll run this method alone if you had set up public\-key authentication 
\&        #       between the ssh client and the ssh server. In this case you only need to call this method
\&        #       to have an authenticated ssh connection, you won\*(Aqt call login(). Note that when you 
\&        #       use public\-key authentication you won\*(Aqt need to set the \*(Aqpassword\*(Aq constructor attribute
\&        #       but you still need to define the \*(Aquser\*(Aq attribute.
\&        #       If you don\*(Aqt know how to setup public\-key authentication there\*(Aqs a good guide at
\&        #       http://sial.org/howto/openssh/publickey\-auth/
\&        #               
\&        # returns:
\&        #       boolean: 1 if the ssh ran OK or 0 otherwise. In case of failures, use $! to do get info.
.Ve
.ie n .IP "string \fBlogin([$login_prompt, \fB$password_prompt\fB] [,$test_success])\fR  \- authenticates on the ssh server." 4
.el .IP "string \fBlogin([$login_prompt, \f(CB$password_prompt\fB] [,$test_success])\fR  \- authenticates on the ssh server." 4
.IX Item "string login([$login_prompt, $password_prompt] [,$test_success])  - authenticates on the ssh server."
.Vb 10
\&        # string login ([$login_prompt, $password_prompt] [,$test_success]) \- authenticates on the ssh server. 
\&        #       This method responds to the authentication prompt sent by the SSH server. 
\&        #       You can customize the "Login:" and "Password:" prompts that must be expected by passing their
\&        #       patterns as arguments to this method, although this method has default values that work to most
\&        #       SSH servers out there.
\&        #       It runs the run_ssh() method only if it wasn\*(Aqt run before(), but it\*(Aqll die
\&        #       if run_ssh() returns false.
\&        #
\&        # param:
\&        #       $login_prompt: A pattern string used to match the "Login:" prompt. The default 
\&        #               pattern is qr/ogin:\es*$/
\&        #
\&        #       $password_prompt: A pattern string used to match the "Password:" prompt. The default
\&        #               pattern is qr/[Pp]assword.*?:|[Pp]assphrase.*?:/
\&        #
\&        #       $test_success: 0 | 1. if 1, login will do an extra\-test to verify if the password
\&        #               entered was accepted. The test consists in verifying if, after sending the password,
\&        #               the "Password" prompt shows up again what would indicate that the password was rejected.
\&        #               This test is disabled by default.
\&        #
\&        #       OBS: the number of paramaters passed to this method will tell it what parameters are being passed:
\&        #       0 parameters: login() : All the default values will be used.
\&        #       1 parameter:  login(1) : The $test_success parameter is set.
\&        #       2 parameters: login("Login:", "Password:") : the $login_prompt and $password_prompt parameters are set.
\&        #       3 parameters: login("Login:", "Password;", 1) : the three parameters received values on this order.
\&        #
\&        # returns:
\&        #       string: whatever the SSH server wrote in my input stream after loging in. This usually is some
\&        #               welcome message and/or the remote prompt. You could use this string to do your verification
\&        #               that the login was successful. The content returned is removed from the input stream.
\&        # dies:
\&        #       IllegalState: if any of \*(Aqhost\*(Aq or \*(Aquser\*(Aq or \*(Aqpassword\*(Aq fields are unset.
\&        #       SSHProccessError: if run_ssh() failed to spawn the ssh process
\&        #       SSHConnectionError: if the connection failed for some reason, like invalid \*(Aqhost\*(Aq address or network problems.
.Ve
.IP "string \fBexec($cmd [,$timeout])\fR \- executes a command in the remote machine returning its output" 4
.IX Item "string exec($cmd [,$timeout]) - executes a command in the remote machine returning its output"
exec('command') runs 'command' in the remote machine and returns all the output generated by 'command' into a string.
.IP "boolean \fBwaitfor($pattern [,$timeout])\fR" 4
.IX Item "boolean waitfor($pattern [,$timeout])"
.Vb 10
\&        # boolean waitfor ($string [, $timeout, $match_type])
\&        # This method reads until a pattern or string is found in the input stream.
\&        # All the characters before and including the match are removed from the input stream.
\&        # 
\&        # After waitfor returns, use the methods before(), match() and after() to get the data
\&        # \*(Aqbefore the match\*(Aq, \*(Aqwhat matched\*(Aq, and \*(Aqafter the match\*(Aq respectively.
\&        #
\&        # If waitfor returns false, whatever content is on input stream can be accessed with 
\&        # before(). In this case before() will return the same content as peek(). 
\&        #
\&        # params:
\&        #       $string: a string to be matched. It can be a regular expression or a literal string
\&        #                        anb its interpretation as one or other depends on $match_type. Default is
\&        #                        \*(Aqre\*(Aq, what treats $string as a regular expression.
\&        #
\&        #       $timeout: the timeout in seconds while waiting for $string
\&        #
\&        #       $match_type: match_type affects how $string will be matched:
\&        #               \*(Aq\-re\*(Aq: means $string is a regular expression.
\&        #               \*(Aq\-ex\*(Aq: means $string is an "exact match", i.e., will be matched literally.
\&        #
\&        # returns: 
\&        #       boolean: 1 is returned if string was found, 0 otherwise. When the match fails
\&        #                        waitfor() will only return after waiting $timeout seconds.
\&        #
\&        # dies:
\&        #       SSH_CONNECTION_ABORTED if EOF is found (error type 2)
\&        #       SSH_PROCESS_ERROR if the ssh process has died (error type 3)
\&        #       SSH_CONNECTION_ERROR if unknown error (type 4) is found
.Ve
.ie n .IP "string \fB\f(BIbefore()\fB\fR \- returns the ""before match"" data of the last \fIwaitfor()\fR call." 4
.el .IP "string \fB\f(BIbefore()\fB\fR \- returns the ``before match'' data of the last \fIwaitfor()\fR call." 4
.IX Item "string before() - returns the before match data of the last waitfor() call."
When \fIwaitfor()\fR matches, if there is any content before the match, this will be returned by \fIbefore()\fR.
.Sp
If the last \fIwaitfor()\fR didn't match, \fIbefore()\fR will return all the current content on the input
stream, just as if you had called \fIpeek()\fR with the same timeout.
.ie n .IP "string \fB\f(BImatch()\fB\fR \- returns the ""match"" data of the last \fIwaitfor()\fR call, or undef if didn't match." 4
.el .IP "string \fB\f(BImatch()\fB\fR \- returns the ``match'' data of the last \fIwaitfor()\fR call, or undef if didn't match." 4
.IX Item "string match() - returns the match data of the last waitfor() call, or undef if didn't match."
.PD 0
.ie n .IP "string \fB\f(BIafter()\fB\fR \- returns the ""after match"" data of the last \fIwaitfor()\fR call, or undef if didn't match." 4
.el .IP "string \fB\f(BIafter()\fB\fR \- returns the ``after match'' data of the last \fIwaitfor()\fR call, or undef if didn't match." 4
.IX Item "string after() - returns the after match data of the last waitfor() call, or undef if didn't match."
.IP "void \fB\f(BIclose()\fB\fR \- terminates the ssh connection" 4
.IX Item "void close() - terminates the ssh connection"
.ie n .IP "void \fBsend($string)\fR \- sends $string to the \s-1SSH\s0 server, returns nothing" 4
.el .IP "void \fBsend($string)\fR \- sends \f(CW$string\fR to the \s-1SSH\s0 server, returns nothing" 4
.IX Item "void send($string) - sends $string to the SSH server, returns nothing"
.PD
Sends the string to the \s-1SSH\s0 server. If the ssh server process is attached to a pseudo-terminal (this is the default)
it is likely that the echo terminal property will be on, what will make the server place the command you just sent in our
input stream, i.e., you'll see the command you sent in your next read operation.
.Sp
To avoid this, try to disable the echo property on the server-side, using
.Sp
.Vb 1
\& $ssh\->exec("stty \-echo");
.Ve
.Sp
It's also advisable to disable the terminal character convertions on server-side, what will make you sure that
every character you sent will be received \*(L"as-is\*(R" to the other side.
.Sp
So you'll probably use this to disable character conversions and echo:
.Sp
.Vb 1
\& $ssh\->exec("stty raw \-echo");
.Ve
.Sp
Of course you're server must support the 'stty' command for that work.
.Sp
To guarantee that your characters are not converted by your local pseudo-terminal before you send them out,
set the constructor option:
.Sp
.Vb 1
\&        raw_pty => 1
.Ve
.Sp
And if you don't need a terminal on the server-side at all, set the constructor option bellow to 1:
.Sp
.Vb 1
\&        no_terminal => 1
.Ve
.IP "string \fBpeek([$timeout])\fR \- returns what is in the input stream without removing anything" 4
.IX Item "string peek([$timeout]) - returns what is in the input stream without removing anything"
.Vb 9
\&        # peek([$timeout]) \- returns what is in the input stream without removing anything
\&        #       peek() returns what is available on the input stream until $timeout seconds.
\&        #       If there is data continuosly arriving on the input stream, subsequent calls to peek() 
\&        #       will return a growing amount of data.
\&        #
\&        # dies:
\&        #       SSH_CONNECTION_ABORTED if EOF is found (error type 2)
\&        #       SSH_PROCESS_ERROR if the ssh process has died (error type 3)
\&        #       SSH_CONNECTION_ERROR if unknown error (type 4) is found
.Ve
.ie n .IP "string \fBeat($string)\fR \- removes all the head of the input stream until $string inclusive." 4
.el .IP "string \fBeat($string)\fR \- removes all the head of the input stream until \f(CW$string\fR inclusive." 4
.IX Item "string eat($string) - removes all the head of the input stream until $string inclusive."
.Vb 10
\&        # string eat($string)\- removes all the head of the input stream until $string inclusive.
\&        #       eat() will only be able to remove the $string if it\*(Aqs currently present on the 
\&        #       input stream because eat() will wait 0 seconds before removing it.
\&        #
\&        #       Use it associated with peek to eat everything that appears on the input stream:
\&        #
\&        #       while ($chunk = $exp\->eat($exp\->peak())) {
\&        #               print $chunk;
\&        #       }
\&        #       
\&        #       Or use the read_all() method that does the above loop for you returning the accumulated
\&        #       result.
\&        #
\&        # param:
\&        #       string: a string currently available on the input stream. 
\&        #               If $string doesn\*(Aqt start in the head, all the content before $string will also
\&        #               be removed. 
\&        #
\&        #               If $string is undef or empty string it will be returned immediately as it.
\&        #       
\&        # returns:
\&        #       string: the removed content or empty string if there is nothing in the input stream.
\&        # 
\&        # dies:
\&        #       SSH_CONNECTION_ABORTED if EOF is found (error type 2)
\&        #       SSH_PROCESS_ERROR if the ssh process has died (error type 3)
\&        #       SSH_CONNECTION_ERROR if unknown error (type 4) is found
\&        #
\&        # debbuging features:
\&        #       The following warnings are printed to STDERR if $exp\->debug() == 1:
\&        #               eat() prints a warning is $string wasn\*(Aqt found in the head of the input stream.
\&        #               eat() prints a warning is $string was empty or undefined.
\&        #
.Ve
.IP "string \fBread_all([$timeout])\fR \- reads and removes all the output from the input stream." 4
.IX Item "string read_all([$timeout]) - reads and removes all the output from the input stream."
The reading/removing process will be interrupted after \f(CW$timeout\fR seconds of inactivity
on the input stream.
.IP "string \fBread_line([$timeout])\fR \- reads the next line from the input stream and returns it." 4
.IX Item "string read_line([$timeout]) - reads the next line from the input stream and returns it."
.Vb 10
\&        # string read_line([$timeout]) \- reads the next line from the input stream
\&        # Read a line of text. A line is considered to be terminated by the \*(Aqteminator\*(Aq
\&        # character. Default is "\en". Lines can also be ended with "\er" or "\er\en".
\&        # Remember to adequate this for your system with the terminator() method. 
\&        # When there are no more lines available, read_line() returns undef. Note that this doen\*(Aqt mean
\&        # there is no data left on input stream since there can be a string not terminated with the 
\&        # \*(Aqterminator\*(Aq character, notably the remote prompt could be left there when read_line() returns
\&        # undef.
\&        #
\&        # params:
\&        #       $timeout: the timeout waiting for a line. Defaults to timeout().
\&        #
\&        # returns:
\&        #       string: a line on the input stream, without the trailing \*(Aqterminator\*(Aq character.
\&        #                       An empty string indicates that the line read only contained the \*(Aqterminator\*(Aq
\&        #                       character (an empty line).
\&        #       undef: when there are no more lines on the input stream.
\&        #
.Ve
.IP "void \fBrestart_timeout_upon_receive( 0 | 1 )\fR \- changes the timeout counter behaviour" 4
.IX Item "void restart_timeout_upon_receive( 0 | 1 ) - changes the timeout counter behaviour"
.Vb 6
\&        # void restart_timeout_upon_receive( 0 | 1 ) \- changes the timeout counter behaviour
\&        # params:
\&        #       boolean: if true, sets the timeout to "inactivity timeout", if false
\&        #                       sets it to "absolute timeout".
\&        # dies:
\&        #       IllegalParamenter if argument is not given.
.Ve
.IP "Expect \fB\f(BIget_expect()\fB\fR \- returns the internal Expect object" 4
.IX Item "Expect get_expect() - returns the internal Expect object"
.RS 4
.PD 0
.IP "params:" 4
.IX Item "params:"
.PD
none
.IP "returns:" 4
.IX Item "returns:"
an \f(CW\*(C`Expect\*(C'\fR object connected to the \s-1SSH\s0 server. It will die if you try to run it without being connected.
.IP "dies:" 4
.IX Item "dies:"
IllegalState: if this there is no valid ssh connection established
.RE
.RS 4
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Net::SCP::Expect, Net::SCP, Net::SSH::Perl, Expect
.SH "REPORTING BUGS"
.IX Header "REPORTING BUGS"
To report bugs please use the bug reporting tool available on \s-1CPAN\s0 website, in the module's page. That way I can
keep track of what I need to do and I can also communicate with you through that tool.
.SH "AUTHOR"
.IX Header "AUTHOR"
Bruno Negrao Guimaraes Zica. <bnegrao@cpan.org>.
.SH "THANKS"
.IX Header "THANKS"
Daniel Berger, author of Net::SCP::Expect. Special thanks to the people helping me improve this module by reporting their tests and the bugs they find.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2007 by Bruno Negrao Guimaraes Zica
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.3 or,
at your option, any later version of Perl 5 you may have available.
